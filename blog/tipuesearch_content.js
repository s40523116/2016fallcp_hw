var tipuesearch = {"pages":[{"title":"用數值控制齒輪配合","text":"網際正齒輪組傳動繪圖 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } Set Number of Gears from browser import document as doc from browser import html import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear2'] ctx = canvas.getContext(\"2d\") # 以 button 驅動的事件函式 def setgearnumber(e): ctx.clearRect(0, 0, canvas.width, canvas.height) x = (canvas.width)/2 y = (canvas.height)/2 if doc[\"n1\"].value.isdigit(): n17 = int(doc[\"n1\"].value) else: n17 = 17 if doc[\"n2\"].value.isdigit(): n11 = int(doc[\"n2\"].value) else: n11 = 11 if doc[\"n3\"].value.isdigit(): n13 = int(doc[\"n3\"].value) else: n13 = 13 # 只使用畫布高度的 80% canvas_size = canvas.height*0.4 r17 = canvas_size*n17/(n17+n11+n13) r11 = canvas_size*n11/(n17+n11+n13) r13 = canvas_size*n13/(n17+n11+n13) # 計算各齒輪中心座標 x17 = x - r17-r11 y17 = y x11 = x y11 = y x13 = x + r11+r13 y13 = y pa = 20 # 開始繪製齒輪 # 儲存原有的座標系統 ctx.save() # 平移到齒輪圓心 ctx.translate(x17, y17) # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平 ctx.rotate(90*deg) # 平移回原來的座標原點 ctx.translate(-x17, -y17) gear17 = Spur(ctx).Gear(x17, y17, r17, n17, pa, \"blue\") # 回復原有的座標系統 ctx.restore() ctx.save() ctx.translate(x11, y11) # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合 ctx.rotate(-90*deg-math.pi/n11) ctx.translate(-x11, -y11) gear11 = Spur(ctx).Gear(x11, y11, r11, n11, pa, \"blue\") ctx.restore() ctx.save() ctx.translate(x13, y13) # 右側齒輪轉動 -90 度加上一齒, 可以與原來標線在左側水平的中間齒輪囓合, 但是目前中間齒輪的標線已經轉了 180 度加或減一次 # 必須配合兩齒的速比轉換旋轉角, 以便讓中間齒輪與右側齒輪囓合 ctx.rotate(-90*deg-math.pi/n13+(180*deg+math.pi/n11)*n11/n13) ctx.translate(-x13, -y13) gear13 = Spur(ctx).Gear(x13, y13, r13, n13, pa, \"blue\") ctx.restore() setgearnumber(True) ''' div = doc[\"onegear2_div\"] form = html.FORM() input1 = html.INPUT(type=\"text\", id=\"n1\", name=\"n1\", value=\"13\") input2 = html.INPUT(type=\"text\", id=\"n2\", name=\"n2\", value=\"11\") input3 = html.INPUT(type=\"text\", id=\"n3\", name=\"n3\", value=\"19\") div <= input1 + html.BR() + input2 + html.BR() + input3 ''' doc['button'].bind('click',setgearnumber)","tags":"論述","url":"./yong-shu-zhi-kong-zhi-chi-lun-pei-he.html"},{"title":"動態繪圖","text":"動態繪圖 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 #cobj = window.Cobj.new shape = window.Shape.new path = window.Path.new creategeartooth = window.createGearTooth.new tweener = window.Tweener.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### def cangoGear(n, m, pa): # n 為齒數 #n = 17 # pa 為壓力角 #pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth #m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = shape(data, { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = path(shapedefs.circle(hr)) shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path # setup the animation # backlash (mm) bklsh = 0.04*m # centre shift to make backlash dC = bklsh/(2*math.tan(math.pi*pa/180)) # np 為小齒輪齒數 np = 20 # gear ratio gr = n/np gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]} # gr*0.666 rpm #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]} # 0.666 rpm # 目前並非以 tweener 執行動畫 #twnr = tweener(0, 90000, \"loop\") return gear # 設定兩齒齒數 n = 10 n2 = 10 reduced_ratio = 0.5 # 使用 80% 的畫布寬度 m = 0.5*canvas.width/((n+n2)*reduced_ratio) # 設定共同的壓力角 pa = 25 # n 齒輪的節圓半徑 pr = n*m/2 # n2 齒輪的節圓半徑 pr2 = n2*m/2 # 建立 gear gear = cangoGear(n, m, pa) cx = canvas.width/2 cy = canvas.height/2 #gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 #cgo.render(gear) # 利用 gear 資料複製一份, 命名為 gear1 #gear1 = gear.dup() # 建立 gear1 gear1 = cangoGear(n2, m, pa) from time import time from browser.timer import request_animation_frame as raf from browser.timer import set_interval deg = math.pi/180 def draw(): cgo.clearCanvas() gear.rotate(2*deg) # 在特定位置, 以特定 scale, 特定 degs 執行 render # 設定囓合點在畫布正中央 # 囓合點往左偏 pr/2 即為 n 齒輪的圓心 x 座標 #cgo.render(gear, {'x':cx-pr*reduced_ratio, 'y':cy, 'scl':reduced_ratio, 'degs':0}) cgo.render(gear, {'x':cx-(pr+pr2)*reduced_ratio, 'y':cy, 'scl':0.5, 'degs':0}) # 根據兩齒輪齒數比決定 n2 齒輪轉速 gear1.rotate(-2*deg*n/n2) # 囓合點往右偏 pr2/2 即為 n2 齒輪的圓心 x 座標, 且 n2 齒轉 180 加一齒角度後囓合 cgo.render(gear1, {'x':cx, 'y':cy, 'scl':reduced_ratio, 'degs':180+(360/n2/2)}) set_interval(draw, 2)","tags":"Misc","url":"./dong-tai-hui-tu.html"},{"title":"漸開線正齒輪輪廓","text":"漸開線正齒輪輪廓 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 0.8*(canvas.height/2) # 齒數 n = 50 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx #ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 cobj = window.Cobj.new creategeartooth = window.createGearTooth.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # n 為齒數 n = 50 # pa 為壓力角 pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = cobj(data, \"SHAPE\", { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = cobj(shapedefs.circle(hr), \"PATH\") shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path cx = canvas.width/2 cy = canvas.height/2 gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 cgo.render(gear)","tags":"Misc","url":"./jian-kai-xian-zheng-chi-lun-lun-kuo.html"},{"title":"50t 與 25t 的齒輪嚙合靜態輪廓圖","text":"50t 與 25t 的齒輪嚙合靜態輪廓圖 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window # 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換 from javascript import JSConstructor import math # 主要用來取得畫布大小 canvas = doc[\"gear1\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx #ctx = canvas.getContext(\"2d\") # 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件 cango = JSConstructor(window.Cango) # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 cobj = JSConstructor(window.Cobj) creategeartooth = JSConstructor(window.createGearTooth) # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"plotarea\" 的 canvas 上 cgo = cango(\"gear1\") ###################################### # 畫正齒輪輪廓 ##################################### def spur(cx, cy, m, n, pa, theta): # n 為齒數 #n = 40 # pa 為壓力角 #pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth #m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = cobj(data, \"SHAPE\", { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) #gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh, 請注意 rotate 角度為 degree # theta 為角度 gearTooth.rotate(theta) # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = cobj(shapedefs.circle(hr), \"PATH\") shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 cgo.render(gear) # 接著繪製齒輪的基準線 deg = math.pi/180 Line = cobj(['M', cx, cy, 'L', cx+pr*math.cos(theta*deg), cy+pr*math.sin(theta*deg)], \"PATH\", { 'strokeColor':'blue', 'lineWidth': 1}) cgo.render(Line) # 2個齒輪的齒數 n1 = 40 n2 = 20 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth # 利用 80% 的畫布寬度進行繪圖 # 計算模數的對應尺寸 m = canvas.width*0.8/(n1+n2) # 根據齒數與模組計算各齒輪的節圓半徑 pr1 = n1*m/2 pr2 = n2*m/2 # 畫布左右兩側都保留畫布寬度的 10% # 依此計算對應的最左邊齒輪的軸心座標 cx = canvas.width*0.1+pr1 cy = canvas.height/2 # pa 為壓力角 pa = 25 # 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy) spur(cx, cy, m, n1, pa, 0) # 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊 # 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合 # 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n spur(cx+pr1+pr2, cy, m, n2, pa, 180-180/n2) # 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置 # 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合 # 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度 # 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3","tags":"Misc","url":"./50t-yu-25t-de-chi-lun-nie-he-jing-tai-lun-kuo-tu.html"},{"title":"W17 繪圖","text":"window.onload=function(){ brython(1); } from browser import document from browser import window from browser import timer import math canvas = document[\"onebar\"] ctx = canvas.getContext(\"2d\") # 畫圓函式 def circle(x,y,r): ctx.beginPath() ctx.arc(x, y, r, 0, math.pi*2, True) ctx.fill() ctx.closePath() # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (200, 200) 座標點 ctx.moveTo(200, 200) # 然後畫直線到 (200, 300) 座標點 ctx.lineTo(200, 300) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() circle(200, 200, 5)","tags":"Course","url":"./w17-hui-tu.html"},{"title":"Brython Canvas 繪圖","text":"Brython Canvas 源自 Canvas API , 以下將介紹 Brython 的繪圖對應 API 使用方法. html5 Canvas cheat sheet Canvas tutorial Canvas demos window.onload=function(){ brython(1); } from browser import document from browser import html canvas = document[\"can1\"] ctx = canvas.getContext(\"2d\") def greensquare(ev): ctx.fillStyle = \"green\" ctx.fillRect(10, 10, 100, 100) def whitesquare(ev): ctx.fillStyle = \"white\" ctx.fillRect(10, 10, 100, 100) document[\"but1\"].bind(\"click\", greensquare) document[\"but2\"].bind(\"click\", whitesquare) 畫綠色矩型 清除 from browser import document from browser import html canvas = document[\"can1\"] ctx = canvas.getContext(\"2d\") def greensquare(ev): ctx.fillStyle = \"green\" ctx.fillRect(10, 10, 100, 100) def whitesquare(ev): ctx.fillStyle = \"white\" ctx.fillRect(10, 10, 100, 100) document[\"but1\"].bind(\"click\", greensquare) document[\"but2\"].bind(\"click\", whitesquare) 畫綠色矩型 清除 以下為基本動畫 ( 程式來源 ): from browser import document from browser import html from browser import alert from browser import timer # 數列內容為圖檔的 URL 連結字串 listImages = [ \"https://nodebox.net/code/data/media/growing_things.jpg\", \"https://nodebox.net/code/data/media/neongolden.jpg\" ] # 以下3個變數, 其資料型別為 dictionary dictImages = {} dictRot = {} dictAnim = {} # anim 為動態繪圖對應變數 anim = None def createIMG(id,src): i = 0 for i in range(len(listImages)): dictImages[i] = html.IMG(src=\"%s\"%listImages[i], id=i, alt=\"Nodebox 圖檔\") dictImages[i].onclick = info dictImages[i].onmouseover = rotateImage dictRot[i] = 0 dictAnim[i] = False def rotateImage(e): e.target.style.cursor = 'pointer' target = int(e.target.id) dictRot[target] += 45 dictAnim[target] = True rot = dictRot[target] e.target.style.webkitTransform = \"rotate(%sdeg)\"%rot def info(e): # 利用 alert() 顯示滑鼠點選 target 的 alt 資料 alert(e.target.alt) lenList = len(listImages) for i in range(lenList): createIMG(i,listImages[i]) def startAnimation(): global dictRot dictRot[0] += 3 rot = dictRot[0] dictImages[0].style.webkitTransform = \"rotate(%sdeg)\"%rot dictImages[1].style.webkitTransform = \"rotate(%sdeg)\"%-rot def launchAnimation(ev): global anim # 初始旋轉, anim 為 None if anim is None: anim = timer.set_interval(startAnimation, 30) # 初始旋轉後, 按鈕文字轉為\"暫停旋轉\" document['but3'].text = '暫停旋轉' elif anim == 'hold': # 當 anim 為 'hold' 表示曾經暫停後的旋轉, 因此持續以 set_interval() 持續旋轉, 且將 but3 文字轉為\"暫停旋轉\" anim = timer.set_interval(startAnimation, 30) document['but3'].text = '暫停旋轉' else: # 初始旋轉後, 使用者再按 but3, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停旋轉 # 且將 anim 變數設為 'hold', 且 but3 文字轉為\"繼續旋轉\" timer.clear_interval(anim) anim = 'hold' document['but3'].text = '繼續旋轉' for i in range(lenList): document[\"content\"] <= dictImages[i] document[\"but3\"].bind(\"click\", launchAnimation) 旋轉圖檔 四連桿模擬: from browser import document from browser import html from browser import timer import math class Coord(object): def __init__(self,x,y): self.x = x self.y = y def __sub__(self,other): # This allows you to substract vectors return Coord(self.x-other.x,self.y-other.y) def __repr__(self): # Used to get human readable coordinates when printing return \"Coord(%f,%f)\"%(self.x,self.y) def length(self): # Returns the length of the vector return math.sqrt(self.x**2 + self.y**2) def angle(self): # Returns the vector's angle return math.atan2(self.y,self.x) def normalize(coord): return Coord( coord.x/coord.length(), coord.y/coord.length() ) def perpendicular(coord): # Shifts the angle by pi/2 and calculate the coordinates # using the original vector length return Coord( coord.length()*math.cos(coord.angle()+math.pi/2), coord.length()*math.sin(coord.angle()+math.pi/2) ) # 點類別 class Point(object): # 起始方法 def __init__(self, x, y): self.x = x self.y = y # 繪製方法 def drawMe(self, g, r): self.g = g self.r = r self.g.save() self.g.moveTo(self.x,self.y) self.g.beginPath() # 根據 r 半徑繪製一個圓代表點的所在位置 self.g.arc(self.x, self.y, self.r, 0, 2*math.pi, True) self.g.moveTo(self.x,self.y) self.g.lineTo(self.x+self.r, self.y) self.g.moveTo(self.x, self.y) self.g.lineTo(self.x-self.r, self.y) self.g.moveTo(self.x, self.y) self.g.lineTo(self.x, self.y+self.r) self.g.moveTo(self.x, self.y) self.g.lineTo(self.x, self.y-self.r) self.g.stroke() self.g.restore() # 加入 Eq 方法 def Eq(self, pt): self.x = pt.x self.y = pt.y # 加入 setPoint 方法 def setPoint(self, px, py): self.x = px self.y = py # 加上 distance(pt) 方法, 計算點到 pt 的距離 def distance(self, pt): self.pt = pt x = self.x - self.pt.x y = self.y - self.pt.y return math.sqrt(x * x + y * y) # 利用文字標示點的座標位置 def tag(self, g): self.g = g self.g.beginPath() self.g.fillText(\"%d, %d\"%(self.x, self.y),self.x, self.y) self.g.stroke() # Line 類別物件 class Line(object): # 起始方法 def __init__(self, p1, p2): self.p1 = p1 self.p2 = p2 # 直線的第一點, 設為線尾 self.Tail = self.p1 # 直線組成的第二點, 設為線頭 self.Head = self.p2 # 直線的長度屬性 self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2)) # setPP 以指定頭尾座標點來定義直線 def setPP(self, p1, p2): self.p1 = p1 self.p2 = p2 self.Tail = self.p1 self.Head = self.p2 self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2)) # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考 def setRT(self, r, t): self.r = r self.t = t x = self.r * math.cos(self.t) y = self.r * math.sin(self.t) self.Tail.Eq(self.p1) self.Head.setPoint(self.Tail.x + x,self.Tail.y + y) # getR 方法 for Line def getR(self): # x 分量與 y 分量 x = self.p1.x - self.p2.x y = self.p1.y - self.p2.y return math.sqrt(x * x + y * y) # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間 def getT(self): x = self.p2.x - self.p1.x y = self.p2.y - self.p1.y if (math.fabs(x) < math.pow(10,-100)): if(y < 0.0): return (-math.pi/2) else: return (math.pi/2) else: return math.atan2(y, x) # setTail 方法 for Line def setTail(self, pt): self.pt = pt self.Tail.Eq(pt) self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y) # getHead 方法 for Line def getHead(self): return self.Head def getTail(self): return self.Tail def drawMe(self, g): self.g = g self.g.beginPath() self.g.moveTo(self.p1.x,self.p1.y) self.g.lineTo(self.p2.x,self.p2.y) self.g.stroke() def test(self): return (\"this is pure test to Inherit\") class Link(Line): def __init__(self, p1, p2): self.p1 = p1 self.p2 = p2 self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2)) #g context def drawMe(self, g): self.g = g hole = 5 radius = 10 length = self.getR() # alert(length) # 儲存先前的繪圖狀態 self.g.save() self.g.translate(self.p1.x,self.p1.y) #alert(str(self.p1.x)+\",\"+str(self.p1.y)) #self.g.rotate(-((math.pi/2)-self.getT())) self.g.rotate(-math.pi*0.5 + self.getT()) #alert(str(self.getT())) #self.g.rotate(10*math.pi/180) #this.g.rotate(-(Math.PI/2-this.getT())); # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上... self.g.beginPath() self.g.moveTo(0,0) self.g.arc(0, 0, hole, 0, 2*math.pi, True) self.g.stroke() self.g.moveTo(0,length) self.g.beginPath() self.g.arc(0,length, hole, 0, 2*math.pi, True) self.g.stroke() self.g.moveTo(0,0) self.g.beginPath() self.g.arc(0,0, radius, 0, math.pi, True) self.g.moveTo(0+radius,0) self.g.lineTo(0+radius,0+length) self.g.stroke() self.g.moveTo(0,0+length) self.g.beginPath() self.g.arc(0, 0+length, radius, math.pi, 0, True) self.g.moveTo(0-radius,0+length) self.g.lineTo(0-radius,0) self.g.stroke() self.g.restore() self.g.beginPath() self.g.fillStyle = \"red\" self.g.font = \"bold 18px sans-serif\" self.g.fillText(\"%d, %d\"%(self.p2.x, self.p2.y),self.p2.x, self.p2.y) self.g.stroke() #self.g.restore() class Triangle(object): def __init__(self, p1, p2, p3): self.p1 = p1 self.p2 = p2 self.p3 = p3 def getLenp3(self): p1 = self.p1 ret = p1.distance(self.p2) return ret def getLenp1(self): p2 = self.p2 ret = p2.distance(self.p3) return ret def getLenp2(self): p1 = self.p1 ret = p1.distance(self.p3) return ret # 角度 def getAp1(self): ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3())) return ret # def getAp2(self): ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3())) return ret def getAp3(self): ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2())) return ret def drawMe(self, g): self.g = g r = 5 # 繪出三個頂點 self.p1.drawMe(self.g,r) self.p2.drawMe(self.g,r) self.p3.drawMe(self.g,r) line1 = Line(self.p1,self.p2) line2 = Line(self.p1,self.p3) line3 = Line(self.p2,self.p3) # 繪出三邊線 line1.drawMe(self.g) line2.drawMe(self.g) line3.drawMe(self.g) # ends Triangle def # 透過三個邊長定義三角形 def setSSS(self, lenp3, lenp1, lenp2): self.lenp3 = lenp3 self.lenp1 = lenp1 self.lenp2 = lenp2 self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3)) self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3)) self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2)) # 透過兩個邊長與夾角定義三角形 def setSAS(self, lenp3, ap2, lenp1): self.lenp3 = lenp3 self.ap2 = ap2 self.lenp1 = lenp1 self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2)) #等於 SSS(AB, BC, CA) def setSaSS(self, lenp2, lenp3, lenp1): self.lenp2 = lenp2 self.lenp3 = lenp3 self.lenp1 = lenp1 if(self.lenp1 > (self.lenp2 + self.lenp3)): #<CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間 ret = math.pi else : # <CAB 夾角為 0, 三點共線且 A 不在 BC 之間 if((self.lenp1 < (self.lenp2 - self.lenp3)) or (self.lenp1 < (self.lenp3 - self.lenp2))): ret = 0.0 else : # 透過餘絃定理求出夾角 <CAB ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3)) return ret # 取得三角形的三個邊長值 def getSSS(self): temp = [] temp.append( self.getLenp1() ) temp.append( self.getLenp2() ) temp.append( self.getLenp3() ) return temp # 取得三角形的三個角度值 def getAAA(self): temp = [] temp.append( self.getAp1() ) temp.append( self.getAp2() ) temp.append( self.getAp3() ) return temp # 取得三角形的三個角度與三個邊長 def getASASAS(self): temp = [] temp.append(self.getAp1()) temp.append(self.getLenp1()) temp.append(self.getAp2()) temp.append(self.getLenp2()) temp.append(self.getAp3()) temp.append(self.getLenp3()) return temp #2P 2L return mid P def setPPSS(self, p1, p3, lenp1, lenp3): temp = [] self.p1 = p1 self.p3 = p3 self.lenp1 = lenp1 self.lenp3 = lenp3 #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output line31 = Line(p3, p1) self.lenp2 = line31.getR() #self.lenp2 = self.p3.distance(self.p1) #這裡是求角3 ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2)) #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3)) bp3 = line31.getT() cp3 = bp3 - ap3 temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y return temp def tag(g, p): None midpt = Point(0, 0) tippt = Point(0, 0) contour = [] # 執行繪圖流程, 注意 x, y 為 global variables def draw(): global theta, midpt, oldpt, p2, p3 context.clearRect(0, 0, canvas.width, canvas.height) line1.drawMe(context) line2.drawMe(context) line3.drawMe(context) #triangle1.drawMe(context) #triangle2.drawMe(context) theta += dx p2.x = p1.x + line1.length*math.cos(theta*degree) p2.y = p1.y - line1.length*math.sin(theta*degree) # 找出一個 bug, 其中 link3_len 與 link2_len 輸入變數顛倒 # 但是動態繪圖應該還有 bugs p3.x, p3.y = triangle2.setPPSS(p2,p4,link3_len,link2_len) # 計算垂直單位向量 a = Coord(p3.x, p3.y) b = Coord(p2.x, p2.y) normal = perpendicular(perpendicular(normalize(a-b))) midpt.x = (p2.x + p3.x)/2 midpt.y = (p2.y + p3.y)/2 tippt.x = midpt.x - 375*normal.x tippt.y = midpt.y - 375*normal.y if theta < 360: contour.append((tippt.x, tippt.y)) context.beginPath() context.moveTo(midpt.x, midpt.y) context.lineTo(tippt.x, tippt.y) # 利用 fillRect 繪製一個長寬各 1 單位的正方形 for i in range(len(contour)): context.fillRect(contour[i][0], contour[i][1], 1, 1) context.stroke() p1.tag(context) # 以上為相關函式物件的定義區 # 全域變數 # 幾何位置輸入變數 x=10 y=10 r=10 # 畫布與繪圖內容 # 其他輸入變數 theta = 0 degree = math.pi/180.0 dx = 2 dy = 4 #set p1.p2.p3.p4 position p1 = Point(100,100) p2 = Point(200,100) p3 = Point(250,math.sqrt(250*250-50*50)+100) p4 = Point(300,100) #accord position create link line1 = Link(p1,p2) line2 = Link(p2,p3) line3 = Link(p3,p4) line4 = Link(p1,p4) line5 = Link(p2,p4) link2_len = p2.distance(p3) link3_len = p3.distance(p4) #link2_len = line1.getR() #link3_len = line3.getR() #alert(str(link2_len)+','+str(link3_len)) triangle1 = Triangle(p1,p2,p4) triangle2 = Triangle(p2,p3,p4) # 視窗載入時執行內容 # 繪圖畫布設定 canvas = document[\"fourbar\"] context = canvas.getContext(\"2d\") # 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角 context.translate(0,canvas.height) context.scale(1,-1) #以間隔 10 micro seconds 重複呼叫 draw() timer.set_interval(draw,10)","tags":"Course","url":"./brython-canvas-hui-tu.html"},{"title":"新年快樂","text":"2017 年元旦快樂 首先了解 random 亂數模組的用法 然後利用 random 模組產生一個介於 1-100 的整數, 列印在網頁上. window.onload=function(){ brython(1); } from browser import document from browser import html import random print_location = document[\"newyear\"] def gen_int(): num = random.randint(1, 49) # 設法將 num 列印在網頁上 #print_location = document[\"newyear\"] print_location <= num + html.BR() def lottery(e): for i in range(6): gen_int() print_location <= \"(可能重複)恭喜中獎!\" + html.BR() #document[\"but1\"].bind(\"click\", gen_int) document[\"but1\"].bind(\"click\", lottery) 產生 1-49 整數亂數 (可能重複) from browser import document from browser import html import random print_location = document[\"newyear\"] def gen_int(): num = random.randint(1, 49) # 設法將 num 列印在網頁上 #print_location = document[\"newyear\"] print_location <= num + html.BR() def lottery(e): for i in range(6): gen_int() print_location <= \"(可能重複)恭喜中獎!\" + html.BR() #document[\"but1\"].bind(\"click\", gen_int) document[\"but1\"].bind(\"click\", lottery) 產生 1-49 整數亂數 (可能重複) 因為上述程式可能會產生相同的號碼, 改用 random.sample() , 使其產生六個不同的整數!! from browser import document from browser import html import random print_location = document[\"newyear\"] def lottery(e): num_list = random.sample(list(range(1, 50)), 6) for i in range(6): print_location <= num_list[i] + html.BR() print_location <= \"(不會重複)恭喜中獎!\" + html.BR() document[\"but2\"].bind(\"click\", lottery) (不會重複)恭喜中獎 from browser import document from browser import html import random print_location = document[\"newyear\"] def lottery(e): num_list = random.sample(list(range(1, 50)), 6) for i in range(6): print_location <= num_list[i] + html.BR() print_location <= \"(不會重複)恭喜中獎!\" + html.BR() document[\"but2\"].bind(\"click\", lottery) 恭喜中獎 以下建立一個猜數字遊戲: from browser import document from browser import html import random id3 = document[\"id3\"] def guess(ev): # 清除 id3 中的內容 id3.clear() id3 <= \"開始玩猜數字遊戲\" + html.BR() 標準答案 = random.randint(1, 100) 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 = 1 while 標準答案 != 你猜的數字: if 標準答案 < 你猜的數字: #print(\"太大了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太大了，再猜一次 :)加油\" + html.BR() else: #print(\"太小了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太小了，再猜一次 :)加油\" + html.BR() 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id3 <= \"猜對了！答案為\" + str(標準答案) + \", 總共猜了\" + str(猜測次數) + \"次\" document[\"but3\"].bind(\"click\", guess) 玩猜數字遊戲 from browser import document from browser import html import random id3 = document[\"id3\"] def guess(ev): # 清除 id3 中的內容 id3.clear() id3 <= \"開始玩猜數字遊戲\" + html.BR() 標準答案 = random.randint(1, 100) 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 = 1 while 標準答案 != 你猜的數字: if 標準答案 < 你猜的數字: #print(\"太大了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太大了，再猜一次 :)加油\" + html.BR() else: #print(\"太小了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太小了，再猜一次 :)加油\" + html.BR() 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id3 <= \"猜對了！答案為\" + str(標準答案) + \", 總共猜了\" + str(猜測次數) + \"次\" document[\"but3\"].bind(\"click\", guess) 玩猜數字遊戲 以下則利用程式執行猜數字遊戲: 利用程式玩猜數字 from browser import document from browser import html import random id4 = document[\"id4\"] def autoguess(ev): 執行次數 = 100 總猜測次數 = 0 for i in range(執行次數): id4 <= \"第\" + str(i+1) + \"次玩:\" + html.BR() 下限 = 1 上限 = 100 標準答案 = random.randint(下限, 上限) pc猜的數字 = random.randint(下限, 上限) #print(標準答案, pc猜的數字) #integer int() #string str() #float float() #你猜的數字 = int(input(\"請輸入您所猜的整數:\")) 猜測次數 = 1 while 標準答案 != pc猜的數字: if 標準答案 < pc猜的數字: #print(\"太大了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 - 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太大了!\" + html.BR() 上限 = pc猜的數字 - 1 else: #print(\"太小了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 + 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太小了!\" + html.BR() 下限 = pc猜的數字 + 1 #pc猜的數字 = int(input(\"請輸入您所猜的整數:\")) pc猜的數字 = random.randint(下限, 上限) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id4 <= \"電腦猜對了, 答案為: \" + str(標準答案) + \", 總共猜了 \"+ str(猜測次數) + \"次\" + html.BR() 總猜測次數 += 猜測次數 平均猜測次數 = int(總猜測次數/執行次數) #print(\"平均次數\", 平均猜測次數) id4 <= \"平均次數: \" + str(平均猜測次數) document[\"but4\"].bind(\"click\", autoguess) from browser import document from browser import html import random id4 = document[\"id4\"] def autoguess(ev): 執行次數 = 100 總猜測次數 = 0 for i in range(執行次數): id4 <= \"第\" + str(i+1) + \"次玩:\" + html.BR() 下限 = 1 上限 = 100 標準答案 = random.randint(下限, 上限) pc猜的數字 = random.randint(下限, 上限) #print(標準答案, pc猜的數字) #integer int() #string str() #float float() #你猜的數字 = int(input(\"請輸入您所猜的整數:\")) 猜測次數 = 1 while 標準答案 != pc猜的數字: if 標準答案 < pc猜的數字: #print(\"太大了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 - 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太大了!\" + html.BR() 上限 = pc猜的數字 - 1 else: #print(\"太小了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 + 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太小了!\" + html.BR() 下限 = pc猜的數字 + 1 #pc猜的數字 = int(input(\"請輸入您所猜的整數:\")) pc猜的數字 = random.randint(下限, 上限) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id4 <= \"電腦猜對了, 答案為: \" + str(標準答案) + \", 總共猜了 \"+ str(猜測次數) + \"次\" + html.BR() 總猜測次數 += 猜測次數 平均猜測次數 = int(總猜測次數/執行次數) #print(\"平均次數\", 平均猜測次數) id4 <= \"平均次數: \" + str(平均猜測次數) document[\"but4\"].bind(\"click\", autoguess) 利用程式玩猜數字","tags":"Course","url":"./xin-nian-kuai-le.html"},{"title":"耶誕快樂","text":"耶誕快樂 window.onload=function(){ brython(1); } from browser import document as do from browser import html c = do[\"con\"] def compa(e): your_input = input(\"請輸入一個整數!\") # 如何判斷所輸入的整數比 10 大 try: if int(your_input) > 10: c <= \"所輸入的整數:\" + your_input + \"比 10 大\" + html.BR() else: c <= \"所輸入的整數:\" + your_input + \"比 10 小\" + html.BR() except: c <= \"請輸入整數!!\" + html.BR() #print(\"test\") ''' for i in range(5): c <= \"test\" + html.BR() ''' do[\"b1\"].bind(\"click\", compa) compa from browser import document as do from browser import html c = do[\"con\"] def compa(e): your_input = input(\"請輸入一個整數!\") # 如何判斷所輸入的整數比 10 大 try: if int(your_input) > 10: c <= \"所輸入的整數:\" + your_input + \"比 10 大\" + html.BR() else: c <= \"所輸入的整數:\" + your_input + \"比 10 小\" + html.BR() except: c <= \"請輸入整數!!\" + html.BR() #print(\"test\") ''' for i in range(5): c <= \"test\" + html.BR() ''' do[\"b1\"].bind(\"click\", compa) compa","tags":"Course","url":"./ye-dan-kuai-le.html"},{"title":"計算機程式 W14 範例整理","text":"本週的學習重點在導入 Leo Editor @clean 節點指令的用法, 利用子節點管理各章節的範例, 逐一將程式改寫為 Brython 格式後, 直接在瀏覽器中執行. 讓學員了解使用階層式架構管理資料的便利性. 以下為 http://mde.tw/2016fallcp/course/Python3Programs.txt 中的 ch01 綜合範例, 其餘範例位於本 Leo Editor 專案檔中的 \"Python3 程式範例\" 節點, 請各組一一將範例程式碼與執行結果, 放入各學員的課程網誌中. 本課程 W15 - W18 週將利用 introduction_to_prog_python3_2012.pdf 與 python_for_everybody_2015.pdf 中有關物件導向的說明, 並且配合 https://github.com/mdecourse/webgame 倉儲中的 Leo Editor 專案, 希望各組能夠了解利用 Python3 與 Brython 語法處理 靜態圖檔 、 動態圖檔 與 網際遊戲 的運作原理, 順利完成各組的期末報告. window.onload=function(){ brython(1); }","tags":"Course","url":"./ji-suan-ji-cheng-shi-w14-fan-li-zheng-li.html"},{"title":"計算機程式 W13","text":"在機械設計工程系的計算機程式課程中, 學習 Python3 的基本目的, 希望在最短時間內, 讓學員能夠除了在身旁的電腦或筆電上, 利用 Python3 程式語法進行各種資料處理與運算外, 還希望學員能夠透過編寫網際程式, 利用網站執行協同設計程式. Python3 能做什麼? Python3 指的是 Python 程式語言第 3 版, 是一種解譯式泛用型程式語言, 能夠在程式碼編寫好了之後, 馬上利用 Python3 解譯器執行, 程式碼是在執行當下才自動轉為機器碼, 因此使用者可以最簡便的方式使用 Python3. 在大一的計算機課程中, 我們利用 Python 編寫的 Leo Editor 作為近端的資料管理與整合程式開發中心, 並利用 Python 編寫的 Pelican 工具, 將使用者建立的 Markdown 格式檔案, 轉為組成 Blog 系統所需要的 html 格式檔案. 使用者所編寫的 Markdown 檔案中可以嵌入格式與 Python3 相容的 Brython 程式碼, 也可以直接在瀏覽器中執行這些 Brython 程式, 進行網際環境中的資料處理與 2D/3D 靜態與動態繪圖. 因此, 在這門課程的範疇中, Python3 能夠做什麼? 簡單說, 我們在此所學習的 Python3 計算機程式語法, 可以在單機操作系統中, 以及瀏覽器中利用電腦進行資料處理、數值運算與繪圖. Python3 的資料處理 Leo Editor 利用大綱模式管理資料, 就是 Python3 程式應用的範例, 至於 Pelican 套件將 Markdown 檔案轉為 Blog 專用的 html 檔案, 也是一系列利用 Python3 指令與語法進行資料處理的過程. 課程進行初始, 本課程利用 Python3 程式進行學員資料的讀取、分組排序, 轉而利用 Brython 直接在網頁上處理學員資料, 也是 Python3 程式進行資料處理的應用之一. Python3 的數值運算 在工程應用中, 最簡單的數值運算就是各種工程尺寸與單位的換算, 在本課程中, 使用者可以利用 Python3 程式語法建立單機與網頁上執行的物理量單位換算程式. Python3 的繪圖 本課程中的 Python3 繪圖應用以在瀏覽器中執行為主, 使用者學會基本的 Brython 程式語法以及 html5 Canvas 繪圖指令後, 就可以直接將 Canvas 繪圖程式寫在 Markdown 檔案中, 然後再利用 Pelican 將檔案轉為 html Python 程式執行 由於本課程主要在 Windows 10 環境中, 以可攜的 Miniconda Python 3.5 系統為主, 使用者啟動後 ,可以利用可攜系統對應的命令列, 輸入 python 後帶出解譯器環境, 就可以直接下指令執行 Python3 程式語法. 此外, 若使用者將 Python3 程式存成 ex1.py, 也可以直接在可攜系統對應的命令列中, 透過 python ex1.py 執行 ex1.py 程式. 當然, 假如 ex1.py 已經利用 Leo Editor 的 @edit 節點指令導入, 也可以在 Leo Editor 環境中, 透過 Ctrl+b 按鍵執行, 而且假如要在 Leo Editor 的 Log 視窗中列印, 可以使用 g.es() 函式, 其中的 g 代表 Leo Editor 的 global 物件, 而 es() 函式則代表 echo string. 本課程 Brython 程式的執行則牽涉 3 個步驟, 也就是導入 brython.js, 啟動 brython, 最後才能 html5 的檔案中, 利用 script 標註執行 Brython 程式. 接下來我們將利用 Hello Mde 字串的列印進行示範. 操作系統中, 進入解譯環境列印: 操作系統中, 呼叫 python 執行 ex1.py 列印: Leo Editor 導入 ex1.py 當作節內容後, 按下 Ctrl+b 列印: Leo Editor 導入 ex1.py 後, 改用 g.es() 函式, 按下 Ctrl+b 列印: 在瀏覽器中以 alert() 函式列印: window.onload=function(){ brython(1); } from browser import document as doc from browser import alert def echo(ev): alert(\"Hello Mde\") doc['alert'].bind('click',echo) 呼叫 alert 列印! from browser import document as doc from browser import alert def echo(ev): alert(\"Hello Mde\") doc['alert'].bind('click',echo) 呼叫 alert 列印! 在瀏覽器中, 直接將執行結果嵌入 html 網頁中: from browser import document as doc # 特殊 html 標註必須透過 html 模組呼叫 # http://www.brython.info/static_doc/en/html.html #from browser import html container = doc[\"ex1\"] container <= \"Hello Mde\" from browser import document as doc # 特殊 html 標註必須透過 html 模組呼叫 # http://www.brython.info/static_doc/en/html.html #from browser import html container = doc[\"ex1\"] container <= \"Hello Mde\" Python3 的繪圖 from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"bat\"] ctx = canvas.getContext(\"2d\") # 開始畫圖 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 利用 transform 將 y 座標反轉, 且 offset canvas.height # (X scale, X skew, Y skew, Y scale, X offset, Y offset) # 繪圖座標放大 5 倍, 並配合圖形位置進行座標轉換 ctx.transform(5, 0, 0, -5, canvas.width/2, canvas.height/2) bat_points = [(5, -1), (6, -2), (8, 0), (10, 4), (12, 8), (13, 12), (13, 16), (15, 15), (19, 15), (22, 15), (24, 15), (26, 16), (25, 14), (23, 10), (22, 6), (19, 5), (17, 3), (16, 1), (15, -3), (15, -7), (13, -8), (11, -10), (9, -12), (8, -14), (7, -18), (5, -16), (1, -14), (0, -14), (-4, -15), (-6, -17), (-8, -15), (-10, -13), (-11, -12), (-12, -12), (-13, -12), (-14, -13), (-17, -15), (-18, -15), (-22, -13), (-24, -12), (-25, -12), (- 27, -13), (-25, -11), (-23, -8), (-21, -5), (-19, 0), (-15, -2), (-12, -4), (-10, -5), (-7, -6), (-4, -6), (-1, -6), (-1, -3), (-2, 1), (0, -1), (1, 0), (2, 0), (3, 1), (3, 3), (5, -1)] ctx.moveTo(3, 3) for point in bat_points: ctx.lineTo(point[0],point[1]) ctx.stroke() ctx.closePath() from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"bat\"] ctx = canvas.getContext(\"2d\") # 開始畫圖 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 利用 transform 將 y 座標反轉, 且 offset canvas.height # (X scale, X skew, Y skew, Y scale, X offset, Y offset) # 繪圖座標放大 5 倍, 並配合圖形位置進行座標轉換 ctx.transform(5, 0, 0, -5, canvas.width/2, canvas.height/2) bat_points = [(5, -1), (6, -2), (8, 0), (10, 4), (12, 8), (13, 12), (13, 16), (15, 15), (19, 15), (22, 15), (24, 15), (26, 16), (25, 14), (23, 10), (22, 6), (19, 5), (17, 3), (16, 1), (15, -3), (15, -7), (13, -8), (11, -10), (9, -12), (8, -14), (7, -18), (5, -16), (1, -14), (0, -14), (-4, -15), (-6, -17), (-8, -15), (-10, -13), (-11, -12), (-12, -12), (-13, -12), (-14, -13), (-17, -15), (-18, -15), (-22, -13), (-24, -12), (-25, -12), (- 27, -13), (-25, -11), (-23, -8), (-21, -5), (-19, 0), (-15, -2), (-12, -4), (-10, -5), (-7, -6), (-4, -6), (-1, -6), (-1, -3), (-2, 1), (0, -1), (1, 0), (2, 0), (3, 1), (3, 3), (5, -1)] ctx.moveTo(3, 3) for point in bat_points: ctx.lineTo(point[0],point[1]) ctx.stroke() ctx.closePath()","tags":"Course","url":"./ji-suan-ji-cheng-shi-w13.html"},{"title":"W12 Brython 繪圖練習","text":"Brython 繪圖 繪圖流程, 導入程式庫, 啟動, 然後引用各種模組開始繪圖. 以下利用函式定義進行和弦底稿繪圖: window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() def canvasText(x, y, fontSize, string, sup, sub, color, ctx): # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color #ctx.font = \"20px Arial\" ctx.font = str(fontSize)+ \"px Arial\" ctx.fillText(string, x, y) ctx.font = str(fontSize-8)+ \"px Arial\" if sup != \"\": ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2) if sub != \"\": ctx.fillText(sup, x+fontSize/1.6, y) ctx.fill() ctx.stroke() ctx.closePath() w = 20 h = 30 background(100, 100, w, h, 5, 5, ctx) mylist = [\"E\", \"A\", \"D\", \"G\", \"B\", \"E\"] num = 0 for s in mylist: #canvasText(100, 80, 20, \"A\", \"b\", \"\", \"black\", ctx) canvasText(100+num*w, 80, 20, s, \"\", \"\", \"black\", ctx) num = num + 1 上述繪圖的程式碼: window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() def canvasText(x, y, fontSize, string, sup, sub, color, ctx): # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color #ctx.font = \"20px Arial\" ctx.font = str(fontSize)+ \"px Arial\" ctx.fillText(string, x, y) ctx.font = str(fontSize-8)+ \"px Arial\" if sup != \"\": ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2) if sub != \"\": ctx.fillText(sup, x+fontSize/1.6, y) ctx.fill() ctx.stroke() ctx.closePath() w = 20 h = 30 background(100, 100, w, h, 5, 5, ctx) canvasText(100, 80, 20, \"A\", \"b\", \"\", \"black\", ctx)","tags":"Course","url":"./w12-brython-hui-tu-lian-xi.html"},{"title":"W11 Brython 繪圖範例","text":"Brython 繪圖 繪圖流程, 導入程式庫, 啟動, 然後引用各種模組開始繪圖 window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") ''' # 改用 background 函式繪圖 # 水平線 for i in range(5): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(99, 100+i*30) ctx.lineTo(201, 100+i*30) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(6): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(100+i*20, 100) ctx.lineTo(100+i*20, 220) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ''' def canvasText(x, y, fontSize, string, sup, sub, color, ctx): # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color #ctx.font = \"20px Arial\" ctx.font = str(fontSize)+ \"px Arial\" ctx.fillText(string, x, y) ctx.font = str(fontSize-8)+ \"px Arial\" if sup != \"\": ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2) if sub != \"\": ctx.fillText(sup, x+fontSize/1.6, y) ctx.fill() ctx.stroke() ctx.closePath() # 設法利用運算印出吉他各把位的音名 def doreme(x, y, fontSize, order, ctx): # EADGBE (guitar string) # FgGaAbBCdDeE (C=Do, D=Re, E=Mi) #簡譜 1 2 3 4 5 6 7 #音名 C D E F G A B #唱名 Do Re Mi Fa Sol La Ti # 讓音名數列可以每 12 音名後, 升高 key 後從頭開始 if order > 12: order = order % 12 if order == 1: canvasText(x, y, fontSize, \"A\", \"\", \"\", \"black\", ctx) elif order ==2: canvasText(x, y, fontSize, \"B\", \"b\", \"\", \"red\", ctx) elif order == 3: canvasText(x, y, fontSize, \"B\", \"\", \"\", \"black\", ctx) elif order == 4: canvasText(x, y, fontSize, \"C\", \"\", \"\", \"black\", ctx) elif order == 5: canvasText(x, y, fontSize, \"D\", \"b\", \"\", \"red\", ctx) elif order == 6: canvasText(x, y, fontSize, \"D\", \"\", \"\", \"black\", ctx) elif order == 7: canvasText(x, y, fontSize, \"E\", \"b\", \"\", \"red\", ctx) elif order == 8: canvasText(x, y, fontSize, \"E\", \"\", \"\", \"black\", ctx) elif order == 9: canvasText(x, y, fontSize, \"F\", \"\", \"\", \"black\", ctx) elif order == 10: canvasText(x, y, fontSize, \"G\", \"b\", \"\", \"red\", ctx) elif order == 11: canvasText(x, y, fontSize, \"G\", \"\", \"\", \"black\", ctx) elif order == 12: canvasText(x, y, fontSize, \"A\", \"b\", \"\", \"red\", ctx) else: canvasText(x, y, fontSize, \"Error\", \"\", \"\", \"red\", ctx) def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"20px Arial\" sixString = [\"E\", \"A\", \"D\", \"G\", \"B\", \"E\"] stringNum = 0 for i in sixString: ctx.fillText(i, x-7+stringNum*xinc, y-30) stringNum = stringNum + 1 ctx.fill() ctx.stroke() ctx.closePath() # EADGBE (guitar string) # FgGaAbBCdDeE (C=Do, D=Re, E=Mi) canvasText(x, y-50, 20, \"A\", \"\", \"\", \"black\", ctx) canvasText(x+xinc, y-50, 20, \"B\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*2, y-50, 20, \"B\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*3, y-50, 20, \"C\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*4, y-50, 20, \"D\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*5, y-50, 20, \"D\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*6, y-50, 20, \"E\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*7, y-50, 20, \"E\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*8, y-50, 20, \"F\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*9, y-50, 20, \"G\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*10, y-50, 20, \"G\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*11, y-50, 20, \"A\", \"b\", \"\", \"red\", ctx) #################################### # 以下利用數列運算, 從已知第1把位的音名分別推算各把位的音名 # 吉他初始音名次序 816(11)38 #################################### firstBar = [8, 1, 6, 11, 3, 8] # j 為往下增量 for j in range(4): # k 為 往右把位初始值 fontSize = 15 for k in range(6): bx = x + (k)*w - fontSize/3 by = y + (j)*h+h/2 + fontSize/2 order = firstBar[k] + j + 1 doreme(bx, by, fontSize, order, ctx) # 一開始 x, y 為圓球圓心, 但是為了配合和弦繪圖 # 將 x, y 改為和弦的左上角座標 x, y # 配合 w, h, wcoord, hcoord 進行運算得到圓的圓心座標 bx, by #def ball(x, y, w, h , wcoord, hcoord, r, color, ctx): def ball(x, y, w, h , wcoord, hcoord, color, ctx): bx = x + (wcoord-1)*w by = y + (hcoord-1)*h+h/2 if w < h: r2 = w/2 -2 else: r2 = h/2 -2 ctx.beginPath() #ctx.fillStyle = 'black' ctx.fillStyle = color #ctx.strokeStyle = \"black\" ctx.strokeStyle = color #ctx.arc(50, 80, 9, 0, 2*math.pi, False) ctx.arc(bx, by, r2, 0, 2*math.pi, False) # 為了疊上各把位的音名, 暫時不填色 #ctx.fill() ctx.stroke() ctx.closePath() x = 300 y = 200 w = 20 h = 30 # 將前面的水平線與垂直線繪圖改用 background 繪圖 background(100, 100, w, h, 5, 4, ctx) background(x, y, w, h, 5, 4, ctx) #background(100, 300, 10, 10, 5, 4, ctx) #background(300, 100, 10, 10, 5, 12, ctx) # 配合 300, 300 的和絃背景, w=30, h=30, (1,1) 位置放入圓 for i in range( 6): for j in range(3): ball(x, y, w, h, i+1, j+1, 'black', ctx) ball(x, y, w, h, 1, 4, 'red', ctx) #ball(300, 300, 30, 20, 1, 1, 9, 'black', ctx) 上述繪圖第一部分使用迴圈繪製水平線與垂直線: from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") # 水平線 for i in range(5): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(99, 100+i*30) ctx.lineTo(201, 100+i*30) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(6): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(100+i*20, 100) ctx.lineTo(100+i*20, 220) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ctx.closePath() 至於將繪圖內容納入 def 函式定義格式後: from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ctx.closePath() background(300, 300, 10, 10, 5, 4, ctx) background(100, 300, 10, 10, 5, 4, ctx) background(300, 100, 10, 10, 5, 12, ctx) 之後進一步將 background 與 ball 配合進行函式設計後: def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ctx.closePath() # 一開始 x, y 為圓球圓心, 但是為了配合和弦繪圖 # 將 x, y 改為和弦的左上角座標 x, y # 配合 w, h, wcoord, hcoord 進行運算得到圓的圓心座標 bx, by # r 最後配合 w 與 h 較小的值進行運算 def ball(x, y, w, h , wcoord, hcoord, color, ctx): bx = x + (wcoord-1)*w by = y + (hcoord-1)*h+h/2 if w < h: r2 = w/2 -2 else: r2 = h/2 -2 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color ctx.arc(bx, by, r2, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() # 利用 x, y 定義和弦左上角座標, 放入的圓也必須配合此一座標運算 x = 300 y = 200 w = 20 h = 30 background(x, y, w, h, 5, 4, ctx) for i in range( 6): for j in range(3): ball(x, y, w, h, i+1, j+1, 'black', ctx) ball(x, y, w, h, 1, 4, 'red', ctx) 註記: 其實使用 html5 CANVAS , 以 png 格式繪製吉他和弦圖, 只是為了讓 Python3 的初學者熟悉變數、數列、迴圈、函式與類別的基本計算機程式語法. 就實用上, 應該要使用 Python3 程式建立 SVG 向量圖. http://www.joebrown.org.uk/wp/?p=8553 就是採用 Python2 與 MySQL 資料庫建立大量的吉他和絃 SVG 圖, 將這個程式改為 Python3 並且配合網際應用 (Flask), 建立一套可以利用程式方法建立各式歌曲的吉他和絃譜, 並且結合 MIDI 或機械手彈奏, 應該是一系列不錯的專題應用.","tags":"Course","url":"./w11-brython-hui-tu-fan-li.html"},{"title":"2016Fall 機械設計主題教學 (cpa)","text":"知識管理與最佳化應用實驗室試圖利用計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 進行與機械設計相關的主題式教學, 其中包含強化創造力的教學、令學員熟習六種工程表達方式, 並且俱備融入協同設計所需要的四大面向知識與技能. 機械設計主題教學 創造力三元素, 機械設計的六種表達, 協同設計的四大面向. 強化創造能力 - 自學力、程式力與想像力 (Creative Competencies) 熟習六種表達 - 口語、文字、2D、3D、理論與實體表達 (Six Presentation Methods) 融入協同設計 - 電腦、網路、軟硬體工具與協同專案 (Collaborative Designs)","tags":"Misc","url":"./2016fall-ji-jie-she-ji-zhu-ti-jiao-xue-cpa.html"}]};